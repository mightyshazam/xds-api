// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFailureState {
    /// What the component configuration would have been if the update had succeeded.
    /// This field may not be populated by xDS clients due to storage overhead.
    #[prost(message, optional, tag = "1")]
    pub failed_configuration: ::core::option::Option<
        super::super::super::google::protobuf::Any,
    >,
    /// Time of the latest failed update attempt.
    #[prost(message, optional, tag = "2")]
    pub last_update_attempt: ::core::option::Option<
        super::super::super::google::protobuf::Timestamp,
    >,
    /// Details about the last failed update attempt.
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
    /// This is the version of the rejected resource.
    /// \[#not-implemented-hide:\]
    #[prost(string, tag = "4")]
    pub version_info: ::prost::alloc::string::String,
}
impl ::prost::Name for UpdateFailureState {
    const NAME: &'static str = "UpdateFailureState";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.UpdateFailureState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.UpdateFailureState".into()
    }
}
/// Envoy's listener manager fills this message with all currently known listeners. Listener
/// configuration information can be used to recreate an Envoy configuration by populating all
/// listeners as static listeners or by returning them in a LDS response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenersConfigDump {
    /// This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
    /// last processed LDS discovery response. If there are only static bootstrap listeners, this field
    /// will be "".
    #[prost(string, tag = "1")]
    pub version_info: ::prost::alloc::string::String,
    /// The statically loaded listener configs.
    #[prost(message, repeated, tag = "2")]
    pub static_listeners: ::prost::alloc::vec::Vec<
        listeners_config_dump::StaticListener,
    >,
    /// State for any warming, active, or draining listeners.
    #[prost(message, repeated, tag = "3")]
    pub dynamic_listeners: ::prost::alloc::vec::Vec<
        listeners_config_dump::DynamicListener,
    >,
}
/// Nested message and enum types in `ListenersConfigDump`.
pub mod listeners_config_dump {
    /// Describes a statically loaded listener.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticListener {
        /// The listener config.
        #[prost(message, optional, tag = "1")]
        pub listener: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Listener was last successfully updated.
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for StaticListener {
        const NAME: &'static str = "StaticListener";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ListenersConfigDump.StaticListener".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ListenersConfigDump.StaticListener"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicListenerState {
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
        /// that the listener was loaded. In the future, discrete per-listener versions may be supported
        /// by the API.
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        /// The listener config.
        #[prost(message, optional, tag = "2")]
        pub listener: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Listener was last successfully updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for DynamicListenerState {
        const NAME: &'static str = "DynamicListenerState";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ListenersConfigDump.DynamicListenerState".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListenerState"
                .into()
        }
    }
    /// Describes a dynamically loaded listener via the LDS API.
    /// \[#next-free-field: 7\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicListener {
        /// The name or unique id of this listener, pulled from the DynamicListenerState config.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The listener state for any active listener by this name.
        /// These are listeners that are available to service data plane traffic.
        #[prost(message, optional, tag = "2")]
        pub active_state: ::core::option::Option<DynamicListenerState>,
        /// The listener state for any warming listener by this name.
        /// These are listeners that are currently undergoing warming in preparation to service data
        /// plane traffic. Note that if attempting to recreate an Envoy configuration from a
        /// configuration dump, the warming listeners should generally be discarded.
        #[prost(message, optional, tag = "3")]
        pub warming_state: ::core::option::Option<DynamicListenerState>,
        /// The listener state for any draining listener by this name.
        /// These are listeners that are currently undergoing draining in preparation to stop servicing
        /// data plane traffic. Note that if attempting to recreate an Envoy configuration from a
        /// configuration dump, the draining listeners should generally be discarded.
        #[prost(message, optional, tag = "4")]
        pub draining_state: ::core::option::Option<DynamicListenerState>,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this particular
        /// resource along with the reason and timestamp. For successfully updated or
        /// acknowledged resource, this field should be empty.
        #[prost(message, optional, tag = "5")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "6")]
        pub client_status: i32,
    }
    impl ::prost::Name for DynamicListener {
        const NAME: &'static str = "DynamicListener";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ListenersConfigDump.DynamicListener".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListener"
                .into()
        }
    }
}
impl ::prost::Name for ListenersConfigDump {
    const NAME: &'static str = "ListenersConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.ListenersConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.ListenersConfigDump".into()
    }
}
/// Envoy's cluster manager fills this message with all currently known clusters. Cluster
/// configuration information can be used to recreate an Envoy configuration by populating all
/// clusters as static clusters or by returning them in a CDS response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClustersConfigDump {
    /// This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
    /// last processed CDS discovery response. If there are only static bootstrap clusters, this field
    /// will be "".
    #[prost(string, tag = "1")]
    pub version_info: ::prost::alloc::string::String,
    /// The statically loaded cluster configs.
    #[prost(message, repeated, tag = "2")]
    pub static_clusters: ::prost::alloc::vec::Vec<clusters_config_dump::StaticCluster>,
    /// The dynamically loaded active clusters. These are clusters that are available to service
    /// data plane traffic.
    #[prost(message, repeated, tag = "3")]
    pub dynamic_active_clusters: ::prost::alloc::vec::Vec<
        clusters_config_dump::DynamicCluster,
    >,
    /// The dynamically loaded warming clusters. These are clusters that are currently undergoing
    /// warming in preparation to service data plane traffic. Note that if attempting to recreate an
    /// Envoy configuration from a configuration dump, the warming clusters should generally be
    /// discarded.
    #[prost(message, repeated, tag = "4")]
    pub dynamic_warming_clusters: ::prost::alloc::vec::Vec<
        clusters_config_dump::DynamicCluster,
    >,
}
/// Nested message and enum types in `ClustersConfigDump`.
pub mod clusters_config_dump {
    /// Describes a statically loaded cluster.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticCluster {
        /// The cluster config.
        #[prost(message, optional, tag = "1")]
        pub cluster: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Cluster was last updated.
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for StaticCluster {
        const NAME: &'static str = "StaticCluster";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ClustersConfigDump.StaticCluster".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ClustersConfigDump.StaticCluster".into()
        }
    }
    /// Describes a dynamically loaded cluster via the CDS API.
    /// \[#next-free-field: 6\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicCluster {
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
        /// that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
        /// the API.
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        /// The cluster config.
        #[prost(message, optional, tag = "2")]
        pub cluster: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Cluster was last updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this particular
        /// resource along with the reason and timestamp. For successfully updated or
        /// acknowledged resource, this field should be empty.
        /// \[#not-implemented-hide:\]
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
    impl ::prost::Name for DynamicCluster {
        const NAME: &'static str = "DynamicCluster";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ClustersConfigDump.DynamicCluster".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ClustersConfigDump.DynamicCluster".into()
        }
    }
}
impl ::prost::Name for ClustersConfigDump {
    const NAME: &'static str = "ClustersConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.ClustersConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.ClustersConfigDump".into()
    }
}
/// Envoy's RDS implementation fills this message with all currently loaded routes, as described by
/// their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
/// or defined inline while configuring listeners are separated from those configured dynamically via RDS.
/// Route configuration information can be used to recreate an Envoy configuration by populating all routes
/// as static routes or by returning them in RDS responses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutesConfigDump {
    /// The statically loaded route configs.
    #[prost(message, repeated, tag = "2")]
    pub static_route_configs: ::prost::alloc::vec::Vec<
        routes_config_dump::StaticRouteConfig,
    >,
    /// The dynamically loaded route configs.
    #[prost(message, repeated, tag = "3")]
    pub dynamic_route_configs: ::prost::alloc::vec::Vec<
        routes_config_dump::DynamicRouteConfig,
    >,
}
/// Nested message and enum types in `RoutesConfigDump`.
pub mod routes_config_dump {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticRouteConfig {
        /// The route config.
        #[prost(message, optional, tag = "1")]
        pub route_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Route was last updated.
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for StaticRouteConfig {
        const NAME: &'static str = "StaticRouteConfig";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.RoutesConfigDump.StaticRouteConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.RoutesConfigDump.StaticRouteConfig"
                .into()
        }
    }
    /// \[#next-free-field: 6\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicRouteConfig {
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
        /// the route configuration was loaded.
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        /// The route config.
        #[prost(message, optional, tag = "2")]
        pub route_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the Route was last updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this particular
        /// resource along with the reason and timestamp. For successfully updated or
        /// acknowledged resource, this field should be empty.
        /// \[#not-implemented-hide:\]
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
    impl ::prost::Name for DynamicRouteConfig {
        const NAME: &'static str = "DynamicRouteConfig";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig"
                .into()
        }
    }
}
impl ::prost::Name for RoutesConfigDump {
    const NAME: &'static str = "RoutesConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.RoutesConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.RoutesConfigDump".into()
    }
}
/// Envoy's scoped RDS implementation fills this message with all currently loaded route
/// configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
/// the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
/// dynamically obtained scopes via the SRDS API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRoutesConfigDump {
    /// The statically loaded scoped route configs.
    #[prost(message, repeated, tag = "1")]
    pub inline_scoped_route_configs: ::prost::alloc::vec::Vec<
        scoped_routes_config_dump::InlineScopedRouteConfigs,
    >,
    /// The dynamically loaded scoped route configs.
    #[prost(message, repeated, tag = "2")]
    pub dynamic_scoped_route_configs: ::prost::alloc::vec::Vec<
        scoped_routes_config_dump::DynamicScopedRouteConfigs,
    >,
}
/// Nested message and enum types in `ScopedRoutesConfigDump`.
pub mod scoped_routes_config_dump {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineScopedRouteConfigs {
        /// The name assigned to the scoped route configurations.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The scoped route configurations.
        #[prost(message, repeated, tag = "2")]
        pub scoped_route_configs: ::prost::alloc::vec::Vec<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the scoped route config set was last updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for InlineScopedRouteConfigs {
        const NAME: &'static str = "InlineScopedRouteConfigs";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs"
                .into()
        }
    }
    /// \[#next-free-field: 7\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicScopedRouteConfigs {
        /// The name assigned to the scoped route configurations.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
        /// the scoped routes configuration was loaded.
        #[prost(string, tag = "2")]
        pub version_info: ::prost::alloc::string::String,
        /// The scoped route configurations.
        #[prost(message, repeated, tag = "3")]
        pub scoped_route_configs: ::prost::alloc::vec::Vec<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the scoped route config set was last updated.
        #[prost(message, optional, tag = "4")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this particular
        /// resource along with the reason and timestamp. For successfully updated or
        /// acknowledged resource, this field should be empty.
        /// \[#not-implemented-hide:\]
        #[prost(message, optional, tag = "5")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "6")]
        pub client_status: i32,
    }
    impl ::prost::Name for DynamicScopedRouteConfigs {
        const NAME: &'static str = "DynamicScopedRouteConfigs";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs"
                .into()
        }
    }
}
impl ::prost::Name for ScopedRoutesConfigDump {
    const NAME: &'static str = "ScopedRoutesConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.ScopedRoutesConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.ScopedRoutesConfigDump".into()
    }
}
/// Envoy's admin fill this message with all currently known endpoints. Endpoint
/// configuration information can be used to recreate an Envoy configuration by populating all
/// endpoints as static endpoints or by returning them in an EDS response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointsConfigDump {
    /// The statically loaded endpoint configs.
    #[prost(message, repeated, tag = "2")]
    pub static_endpoint_configs: ::prost::alloc::vec::Vec<
        endpoints_config_dump::StaticEndpointConfig,
    >,
    /// The dynamically loaded endpoint configs.
    #[prost(message, repeated, tag = "3")]
    pub dynamic_endpoint_configs: ::prost::alloc::vec::Vec<
        endpoints_config_dump::DynamicEndpointConfig,
    >,
}
/// Nested message and enum types in `EndpointsConfigDump`.
pub mod endpoints_config_dump {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticEndpointConfig {
        /// The endpoint config.
        #[prost(message, optional, tag = "1")]
        pub endpoint_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// \[#not-implemented-hide:\] The timestamp when the Endpoint was last updated.
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    impl ::prost::Name for StaticEndpointConfig {
        const NAME: &'static str = "StaticEndpointConfig";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig"
                .into()
        }
    }
    /// \[#next-free-field: 6\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicEndpointConfig {
        /// \[#not-implemented-hide:\] This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
        /// the endpoint configuration was loaded.
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        /// The endpoint config.
        #[prost(message, optional, tag = "2")]
        pub endpoint_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// \[#not-implemented-hide:\] The timestamp when the Endpoint was last updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this particular
        /// resource along with the reason and timestamp. For successfully updated or
        /// acknowledged resource, this field should be empty.
        /// \[#not-implemented-hide:\]
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
    impl ::prost::Name for DynamicEndpointConfig {
        const NAME: &'static str = "DynamicEndpointConfig";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig"
                .into()
        }
    }
}
impl ::prost::Name for EndpointsConfigDump {
    const NAME: &'static str = "EndpointsConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.EndpointsConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.EndpointsConfigDump".into()
    }
}
/// Envoy's ECDS service fills this message with all currently extension
/// configuration. Extension configuration information can be used to recreate
/// an Envoy ECDS listener and HTTP filters as static filters or by returning
/// them in ECDS response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcdsConfigDump {
    /// The ECDS filter configs.
    #[prost(message, repeated, tag = "1")]
    pub ecds_filters: ::prost::alloc::vec::Vec<ecds_config_dump::EcdsFilterConfig>,
}
/// Nested message and enum types in `EcdsConfigDump`.
pub mod ecds_config_dump {
    /// \[#next-free-field: 6\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EcdsFilterConfig {
        /// This is the per-resource version information. This version is currently
        /// taken from the :ref:`version_info
        /// <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
        /// field at the time that the ECDS filter was loaded.
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        /// The ECDS filter config.
        #[prost(message, optional, tag = "2")]
        pub ecds_filter: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        /// The timestamp when the ECDS filter was last updated.
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        /// Set if the last update failed, cleared after the next successful update.
        /// The ``error_state`` field contains the rejected version of this
        /// particular resource along with the reason and timestamp. For successfully
        /// updated or acknowledged resource, this field should be empty.
        /// \[#not-implemented-hide:\]
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        /// The client status of this resource.
        /// \[#not-implemented-hide:\]
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
    impl ::prost::Name for EcdsFilterConfig {
        const NAME: &'static str = "EcdsFilterConfig";
        const PACKAGE: &'static str = "envoy.admin.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig".into()
        }
    }
}
impl ::prost::Name for EcdsConfigDump {
    const NAME: &'static str = "EcdsConfigDump";
    const PACKAGE: &'static str = "envoy.admin.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.admin.v3.EcdsConfigDump".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.admin.v3.EcdsConfigDump".into()
    }
}
/// Resource status from the view of a xDS client, which tells the synchronization
/// status between the xDS client and the xDS server.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientResourceStatus {
    /// Resource status is not available/unknown.
    Unknown = 0,
    /// Client requested this resource but hasn't received any update from management
    /// server. The client will not fail requests, but will queue them until update
    /// arrives or the client times out waiting for the resource.
    Requested = 1,
    /// This resource has been requested by the client but has either not been
    /// delivered by the server or was previously delivered by the server and then
    /// subsequently removed from resources provided by the server. For more
    /// information, please refer to the :ref:`"Knowing When a Requested Resource
    /// Does Not Exist" <xds_protocol_resource_not_existed>` section.
    DoesNotExist = 2,
    /// Client received this resource and replied with ACK.
    Acked = 3,
    /// Client received this resource and replied with NACK.
    Nacked = 4,
    /// Client received an error from the control plane. The attached config
    /// dump is the most recent accepted one. If no config is accepted yet,
    /// the attached config dump will be empty.
    ReceivedError = 5,
    /// Client timed out waiting for the resource from the control plane.
    Timeout = 6,
}
impl ClientResourceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Requested => "REQUESTED",
            Self::DoesNotExist => "DOES_NOT_EXIST",
            Self::Acked => "ACKED",
            Self::Nacked => "NACKED",
            Self::ReceivedError => "RECEIVED_ERROR",
            Self::Timeout => "TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "REQUESTED" => Some(Self::Requested),
            "DOES_NOT_EXIST" => Some(Self::DoesNotExist),
            "ACKED" => Some(Self::Acked),
            "NACKED" => Some(Self::Nacked),
            "RECEIVED_ERROR" => Some(Self::ReceivedError),
            "TIMEOUT" => Some(Self::Timeout),
            _ => None,
        }
    }
}
